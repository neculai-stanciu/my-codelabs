
<!doctype html>

<html>
<head>
  <meta name="viewport" content="width=device-width, minimum-scale=1.0, initial-scale=1.0, user-scalable=yes">
  <meta name="theme-color" content="#4F7DC9">
  <meta charset="UTF-8">
  <title>Representational state transfer</title>
  <script src="../../bower_components/webcomponentsjs/webcomponents-lite.js"></script>
  <link rel="import" href="../../elements/codelab.html">
  <link rel="stylesheet" href="//fonts.googleapis.com/css?family=Source+Code+Pro:400|Roboto:400,300,400italic,500,700|Roboto+Mono">
  <style is="custom-style">
    body {
      font-family: "Roboto",sans-serif;
      background: var(--google-codelab-background, #F8F9FA);
    }
  </style>
  
</head>
<body unresolved class="fullbleed">

  <google-codelab title="Representational state transfer"
                  environment="web"
                  feedback-link="https://github.com/neculai-stanciu/my-codelabs/issues">
    
      <google-codelab-step label="What is REST" duration="25">
        <p>Representational state transfer (REST) is a software architectural style that defines a set of constraints to be used for creating Web services. Web services that conform to the REST architectural style, called RESTful Web services, provide interoperability between computer systems on the Internet. RESTful Web services allow the requesting systems to access and manipulate textual representations of Web resources by using a uniform and predefined set of stateless operations.</p>
<p>&#34;Web resources&#34; were first defined on the World Wide Web as documents or files identified by their URLs. However, today they have a much more generic and abstract definition that encompasses every thing or entity that can be identified, named, addressed, or handled, in any way whatsoever, on the Web. In a RESTful Web service, requests made to a resource&#39;s URI will elicit a response with a payload formatted in HTML, XML, JSON, or some other format. The response can confirm that some alteration has been made to the stored resource, and the response can provide hypertext links to other related resources or collections of resources. When HTTP is used, as is most common, the operations (HTTP methods) available are GET, HEAD, POST, PUT, PATCH, DELETE, CONNECT, OPTIONS and TRACE.</p>
<p>By using a stateless protocol and standard operations, RESTful systems aim for fast performance, reliability, and the ability to grow by reusing components that can be managed and updated without affecting the system as a whole, even while it is running.</p>
<p>The term representational state transfer was introduced and defined in 2000 by Roy Fielding in his doctoral dissertation. Fielding&#39;s dissertation explained the REST principles that were known as the &#34;HTTP object model&#34; beginning in 1994, and were used in designing the HTTP 1.1 and Uniform Resource Identifiers (URI) standards. The term is intended to evoke an image of how a well-designed Web application behaves: it is a network of Web resources (a virtual state-machine) where the user progresses through the application by selecting resource identifiers such as <code>http://www.example.com/articles/21</code> and resource operations such as GET or POST (application state transitions), resulting in the next resource&#39;s representation (the next application state) being transferred to the end user for their use.</p>
<p>Source: <a href="https://en.wikipedia.org/wiki/Representational_state_transfer" target="_blank">Wikipedia</a></p>


      </google-codelab-step>
    
      <google-codelab-step label="Architectural properties" duration="20">
        <p>The constraints of the REST architectural style affect the following architectural properties:</p>
<ul>
<li>performance in component interactions, which can be the dominant factor in user-perceived performance and network efficiency;</li>
<li>simplicity of a uniform interface;</li>
<li>modifiability of components to meet changing needs (even while the application is running);</li>
<li>visibility of communication between components by service agents;</li>
<li>portability of components by moving program code with the data;</li>
<li>reliability in the resistance to failure at the system level in the presence of failures within components, connectors, or data.</li>
<li>scalability allowing the support of large numbers of components and interactions among components. Roy Fielding describes REST&#39;s effect on scalability as follows:</li>
</ul>
<aside class="special"><p>REST&#39;s client-server separation of concerns simplifies component implementation, reduces the complexity of connector semantics, improves the effectiveness of performance tuning, and increases the scalability of pure server components. Layered system constraints allow intermediaries—proxies, gateways, and firewalls—to be introduced at various points in the communication without changing the interfaces between components, thus allowing them to assist in communication translation or improve performance via large-scale, shared caching. REST enables intermediate processing by constraining messages to be self-descriptive: interaction is stateless between requests, standard methods and media types are used to indicate semantics and exchange information, and responses explicitly indicate cacheability.</p>
</aside>
<p>Source: <a href="https://en.wikipedia.org/wiki/Representational_state_transfer" target="_blank">Wikipedia</a></p>


      </google-codelab-step>
    
      <google-codelab-step label="Architectural constraints" duration="10">
        <p>Six guiding constraints define a RESTful system. These constraints restrict the ways that the server can process and respond to client requests so that, by operating within these constraints, the system gains desirable non-functional properties, such as performance, scalability, simplicity, modifiability, visibility, portability, and reliability. If a system violates any of the required constraints, it cannot be considered RESTful.</p>
<p>The formal REST constraints are as follows:</p>
<ul>
<li>Client-Server Architecture<br>The simple goal of this constraint is the separation of concerns between client and server.</li>
<li>Stateless Communication<br>This constraint improves scalability, visibility and reliability by simplifying the server implementation.</li>
<li>Explicit Caching<br>&#34;An interesting observation is that the most efficient network request is one that doesn&#39;t use the network.&#34; — Fielding in his dissertation.<br>I think it is pretty clear why caching is desirable.</li>
<li>Layered System<br>The layered system constraint aims to reduce complexity by encapsulating legacy services and introducing intermediary systems. Even though this is adding a bit of overhead, it can be offset by using caches in the REST architectural style.</li>
<li>Uniform Interface<br>This is really the main constraint distinguishing REST from other styles. A uniform interface means that client and server can evolve independently and components are decoupled. It is not this simple in reality though, as I will explain later.</li>
<li>An optional constraint for Code-on-Demand can be used, but as it is optional I will not discuss it further.</li>
</ul>
<p>Source: <a href="https://medium.com/@andreasreiser94/why-hateoas-is-useless-and-what-that-means-for-rest-a65194471bc8" target="_blank">Medium.com blog</a></p>


      </google-codelab-step>
    
      <google-codelab-step label="REST applied to Web services" duration="10">
        <p>Web service APIs that adhere to the REST architectural constraints are called RESTful APIs. HTTP-based RESTful APIs are defined with the following aspects:</p>
<ul>
<li>a base URI, such as <a href="http://api.example.com/collection/" target="_blank">http://api.example.com/collection/</a></li>
<li>standard HTTP methods (e.g., GET, POST, PUT, PATCH and DELETE);</li>
<li>a media type that defines state transition data elements (e.g., Atom, microformats, application/vnd.collection+json, etc.). The current representation tells the client how to compose requests for transitions to all the next available application states. This could be as simple as a URI or as complex as a Java applet.</li>
</ul>
<h2>Relationship between URI and HTTP methods</h2>
<p>The following table shows how HTTP methods are typically used in a RESTful API.</p>
<table>
<tr></tr>
<tr><td colspan="1" rowspan="1"><p>GET</p>
</td><td colspan="1" rowspan="1"><p>Retrieve the URIs of the member resources of the collection resource in the response body.</p>
</td><td colspan="1" rowspan="1"><p>Retrieve representation of the member resource in the response body.</p>
</td></tr>
<tr><td colspan="1" rowspan="1"><p>POST</p>
</td><td colspan="1" rowspan="1"><p>Create a member resource in the collection resource using the instructions in the request body. The URI of the created member resource is automatically assigned and returned in the response Location header field.</p>
</td><td colspan="1" rowspan="1"><p>Create a member resource in the member resource using the instructions in the request body. The URI of the created member resource is automatically assigned and returned in the response Location header field.</p>
</td></tr>
<tr><td colspan="1" rowspan="1"><p>PUT</p>
</td><td colspan="1" rowspan="1"><p>Replace all the representations of the member resources of the collection resource with the representation in the request body, or create the collection resource if it does not exist.</p>
</td><td colspan="1" rowspan="1"><p>Replace all the representations of the member resource or create the member resource if it does not exist, with the representation in the request body.</p>
</td></tr>
<tr><td colspan="1" rowspan="1"><p>PATCH</p>
</td><td colspan="1" rowspan="1"><p>Update all the representations of the member resources of the collection resource using the instructions in the request body, or may create the collection resource if it does not exist.</p>
</td><td colspan="1" rowspan="1"><p>Update all the representations of the member resource, or may create the member resource if it does not exist, using the instructions in the request body.</p>
</td></tr>
<tr><td colspan="1" rowspan="1"><p>DELETE</p>
</td><td colspan="1" rowspan="1"><p>Delete all the representations of the member resources of the collection resource.</p>
</td><td colspan="1" rowspan="1"><p>Delete all the representations of the member resource.</p>
</td></tr>
</table>
<p>The GET method is <a href="https://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol#Safe_methods" target="_blank">safe</a>, meaning that applying it to a resource does not result in a state change of the resource (read-only semantics). The GET, PUT and DELETE methods are <a href="https://en.wikipedia.org/wiki/Idempotent#Computer_science_meaning" target="_blank">idempotent</a>, meaning that applying them multiple times to a resource result in the same state change of the resource as applying them once, though the response might differ.</p>


      </google-codelab-step>
    
  </google-codelab>

  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
    ga('create', 'UA-49880327-14', 'auto');

    (function() {
      var gaCodelab = '';
      if (gaCodelab) {
        ga('create', gaCodelab, 'auto', {name: 'codelab'});
      }

      var gaView;
      var parts = location.search.substring(1).split('&');
      for (var i = 0; i < parts.length; i++) {
        var param = parts[i].split('=');
        if (param[0] === 'viewga') {
          gaView = param[1];
          break;
        }
      }
      if (gaView && gaView !== gaCodelab) {
        ga('create', gaView, 'auto', {name: 'view'});
      }
    })();
  </script>

</body>
</html>
